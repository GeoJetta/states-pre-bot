#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    gyro,           sensorNone)
#pragma config(Sensor, in2,    chainbarPot,    sensorPotentiometer)
#pragma config(Sensor, in3,    mogoPot,        sensorPotentiometer)
#pragma config(Sensor, in4,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in5,    mogoSense,      sensorLineFollower)
#pragma config(Sensor, in8,    pwrExpStatus,   sensorAnalog)
#pragma config(Sensor, dgtl1,  driveEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, stackDetect,    sensorSONAR_mm)
#pragma config(Motor,  port1,           mogo,          tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           backLeftChassis, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           frontLeftChassis, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           rChainbar,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rLift,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           lChainbar,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           lLift,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           frontRightChassis, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           backRightChassis, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          intake,        tmotorVex393_HBridge, openLoop, reversed)
#pragma config(DatalogSeries, 0, "lMotor", Motors, MotorPower, port6, 10)
#pragma config(DatalogSeries, 1, "rMotor", Motors, MotorPower, port4, 10)
#pragma config(DatalogSeries, 2, "lMotorP", Motors, MotorPWM, port6, 10)
#pragma config(DatalogSeries, 3, "rMotorP", Motors, MotorPWM, port4, 10)
#pragma config(DatalogSeries, 4, "lLift", Motors, MotorPower, port7, 10)
#pragma config(DatalogSeries, 5, "rLift", Motors, MotorPower, port5, 10)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"
#include "general.h"
#include "motion.h"
#include "lift.h"
#include "manipulators.h"
#include "chassis.h"
#include "auton.h"
#include "lcd.h"

void pre_auton()
{

	bStopTasksBetweenModes = false;
	bDisplayCompetitionStatusOnLcd = false;

	PIDInit( distancePIDValues, 0.2, 0, 0, 0, 0, CHASSIS_DISTANCE_SENSOR, 150, 200, 200 );
	PIDInit( sDistancePIDValues, 1.3, 0, 0.2, 0, 0, CHASSIS_DISTANCE_SENSOR, 100, 20, 30 );
	PIDInit( gyroPIDValues, 0.6, 0, 0.05, 0, 0, gyro, 150, 30, 200 );
	PIDInit( mogoPIDValues, 1.0, 0, 0.05, 0, 0, mogoPot, 5, 40, 200 );
	PIDInit( liftPIDValues, -0.2, 0, -0.02, 0, 0, LIFT_SENSOR, 150, 200, 250 );
	PIDInit( chainbarPIDValues, 0.2, 0, 0.01, 0, 0, chainbarPot, 50, 100, 300 );

	initLCD();

	startTask( LCD );

}

task autonomous()
{

	runAuton();

}

float time;

task autonTask
{

	runAuton();

}

task usercontrol()
{

	startTask( PIDLoop );

	while( true )
	{

		//while( !vexRT[ Btn8D ] )
		//	wait1Msec( 20 );

		//while( vexRT[ Btn8D ] )
		//	wait1Msec( 20 );

		//float startTime = nPgmTime;

		//clearTimer(T1);

		//startTask( autonTask );

		//while( time1[T1] < 15000 && !vexRT[ Btn8D ] )
		//	wait1Msec( 20 );

		//stopTask( autonTask );

		//time = nPgmTime - startTime;

		//liftPIDEnabled = false;
		//chainbarPIDEnabled = false;
		//chassisPIDEnabled = false;
		//mogoPIDEnabled = false;
		//distancePIDEnabled = false;
		//turnPIDEnabled = false;

		//setChassis(0,0);
		//setLift(0);
		//setChainbar(0);
		//setMogo(0);
		//setIntake(0);

		//wait1Msec( 200 );

		//while( !vexRT[ Btn8D ] )
		//	wait1Msec( 20 );

		//clearTimer(T1);

	 // while ( time10[T1] < 10500 )
	 // {

	  	//driverLift(  );
			stateSwitch(  );

			if( SensorValue[ mogoPot ] < MOGO_DOWN_POS + 200 )
				motor[ mogo ] = vexRT[ Btn7UXmtr2 ] * 147 - vexRT[ Btn7DXmtr2 ] * 127 - 20;
			else
				motor[ mogo ] = vexRT[ Btn7UXmtr2 ] * 127 - vexRT[ Btn7DXmtr2 ] * 127;

			if( vexRT[ Btn7UXmtr2 ] || vexRT[ Btn7DXmtr2 ] || vexRT[ Btn7LXmtr2 ] )
				lastLiftPoint = 4000;

	  	setChassis( deadzone( vexRT[ Ch3 ], 10 ), deadzone( vexRT[ Ch2 ], 10 ) );

		  updateAllBtnToggle();

	  	wait1Msec( 20 );

	 // }

	 // setChassis(0,0);
		//setLift(0);
		//setChainbar(0);
		//setMogo(0);

	}

}
